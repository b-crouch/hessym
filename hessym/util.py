import numpy as np
from xml import etree
import yaml
import pandas as pd

def load_lammps_hessian(filepath, atomic_mass):
    """
    Loads the mass-normalized LAMMPS dynamical matrix at `filepath` into a (3N)*(3N) Hessian matrix without mass normalization
    A separate call to `load_simulation_box` is needed to obtain the position data needed for symmetry analysis
    Params:
        filepath (str): Filepath to dynamical matrix outputted by LAMMPS `dynamical_matrix` command
        atomic_mass (float): Mass of atoms in crystal in AMU
    Return:
        hessian (np.array): (3N)*(3N) Hessian matrix without mass normalization
    """
    dynamical_matrix = np.loadtxt(filepath)
    n_atoms = int(np.sqrt(len(dynamical_matrix)//3))
    hessian = dynamical_matrix.reshape((3*n_atoms, 3*n_atoms))*atomic_mass
    return hessian

def load_vasp_hessian(filepath):
    """
    Loads the (3N)*(3N) Hessian and position data from a VASP vasprun.xml file generated by IBRION = 5, 6, 7, or 8
    Params:
        filepath (str): Filepath to vasprun.xml file
    Return:
        positions (np.array): Position coordinates of all atoms in structure
        hessian (np.array): (3N)*(3N) Hessian matrix
    """
    input_obj = open(filepath,"r")
    input_doc = etree.parse(input_obj)
    root = input_doc.getroot()

    frac_coordinates_txt = root.xpath("//varray[@name='positions']")[0].xpath("v/text()")
    frac_coordinates = np.array([pos_row.split() for pos_row in frac_coordinates_txt], dtype=float)

    hessian_txt = root.xpath("*/dynmat/varray[@name='hessian']")[0].xpath("v/text()")
    hessian = np.array([hess_row.split() for hess_row in hessian_txt], dtype=float)

    basis_txt = root.xpath("///varray[@name='basis']")[0].xpath("v/text()")
    basis = np.array([basis_row.split() for basis_row in basis_txt], dtype=float)

    positions = frac_coordinates@basis

    return positions, hessian

def load_phonopy_hessian(filepath):
    """
    Loads the (3N)*(3N) Hessian and position data from a phonopy `phonopy.yaml` file
    Params:
        filepath (str): Filepath to phonopy.yaml file
    Return:
        positions (np.array): Position coordinates of all atoms in structure
        box_dim (np.array): Length of simulation box along the x, y, and z axes 
        hessian (np.array): (3N)*(3N) Hessian matrix
    """
    with open(filepath, "rb") as f:
        yaml_file = yaml.safe_load(f)
    raw_hessian = np.vstack(np.array(yaml_file["force_constants"]["elements"]))
    n_atoms = int(yaml_file["force_constants"]["shape"][0])

    hessian = np.zeros((3*n_atoms, 3*n_atoms))
    for atom_idx in range(n_atoms):
        hessian[3*atom_idx:3*atom_idx+3, :] = raw_hessian[atom_idx*(3*n_atoms):(atom_idx*(3*n_atoms) + 3*n_atoms)].T

    basis = np.array(yaml_file["supercell"]["lattice"])
    frac_coordinates = np.array([atom["coordinates"] for atom in yaml_file["supercell"]["points"]])
    positions = frac_coordinates@basis
    box_dim = basis[~np.isclose(basis, 0)]

    return positions, box_dim, hessian


def load_lammps_positions(filepath, n_atoms_line_num=2, box_dim_line_num=5, positions_line_num=15, tds=False):
    """
    Loads the LAMMPS simulation box position data at `filepath`
    Params:
        filepath (str): Filepath to simulation box data outputted by LAMMPS `write_data` command
        n_atoms_line_num (int): Line number (0-indexed) at which the number of atoms is recorded in data file at `filepath`
        box_dim_line_num (int): Starting line number (0-indexed) at which the box dimensions are recorded in data file at `filepath`
        positions_line_num (int): Starting line number (0-indexed) at which the atomic positions are recorded in data file at `filepath`
        tds (bool): The test files used in the original TDS code appear to have been generated with an older version of LAMMPS that uses different file formatting.
                    When `tds=True`, load the simulation box using the old formatting style
    Return:
        positions (np.array): Position coordinates of all atoms in simulation box
        box_dim (np.array): Length of simulation box along the x, y, and z axes 
    """
    if tds:
        n_atoms = np.genfromtxt(filepath, skip_header=n_atoms_line_num, max_rows=1, dtype=int)[0]
        box_dim = np.genfromtxt(filepath, skip_header=box_dim_line_num, max_rows=3, dtype=float)[:, 1]
        positions = np.genfromtxt(filepath, skip_header=19, max_rows=n_atoms, dtype=float)[:, 4:7] 
    else:
        # If TDS LAMMPS test file is used, positions_line_num=19
        n_atoms = np.genfromtxt(filepath, skip_header=n_atoms_line_num, max_rows=1, dtype=int)[0]
        box_dim = np.genfromtxt(filepath, skip_header=box_dim_line_num, max_rows=3, dtype=float)[:, 1]

        # If TDS LAMMPS test file is used, this should be 4:7
        positions = np.genfromtxt(filepath, skip_header=positions_line_num, max_rows=n_atoms, dtype=float)[:, 2:5] 

    # NN analysis often fails due to rounding errors in LAMMPS output; implement a heuristic fix
    positions = np.round(positions*10**14)/10**14
    return positions, box_dim


def get_fractional_coordinates(positions, lattice):
    """
    Given atomic `positions` expressed in Cartesian coordinates, computes the fractional coordinates of each site
    in the basis of `lattice` (POSCAR format, where each row represents a lattice vector)
    Params:
        positions (np.array): `n_atoms` x 3 array containing Cartesian coordinates of atomic positions (e.g., from `load_simulation_box`)
        lattice (np.array): 3x3 array where each row represents a primitive lattice vector
    Return:
        frac_coordinates (np.array): `n_atoms` x 3 array containing fractional coordinates of atomic positions in provided basis
    """
    frac_coordinates = positions@np.linalg.inv(lattice)
    return frac_coordinates


def load_poscar(filepath):
    """
    Loads lattice and motif specifications from POSCAR
    Params:
        filepath (str): Filepath to POSCAR
    Return:
        lattice (np.array): 3x3 array where each row represents a primitive lattice vector
        frac_coordinates (np.array): `n_atoms` x 3 array containing fractional coordinates of atomic positions in provided basis
    """
    lattice = np.genfromtxt(filepath, skip_header=2, max_rows=3, dtype=float)
    n_atoms = np.genfromtxt(filepath, skip_header=6, max_rows=1, dtype=int)
    frac_coordinates = np.genfromtxt(filepath, skip_header=8, max_rows=n_atoms, dtype=float)[:, :-1]
    return lattice, frac_coordinates


def generate_lammps_input_from_phonopy_yaml(filepath):
    """
    Generates custom LAMMPS lattice from Phonopy YAML
    Copy and paste the printed text into `input.lammps`
    """
    with open(filepath, "rb") as f:
        yaml_file = yaml.safe_load(f)

    basis = np.array(yaml_file["supercell"]["lattice"])
    frac_coordinates = np.array([atom["coordinates"] for atom in yaml_file["supercell"]["points"]])

    print("lattice custom 1.00 &")
    for i, vec in enumerate(basis):
        print(f"\t a{i+1}", *vec, "&")

    for atom in frac_coordinates:
        print("\t basis", *atom, "&")

def read_dat(file):
    """
    Reads a .dat file for dispersion or DOS data generated by Phonopy into a Pandas DataFrame
    """
    return pd.DataFrame(np.loadtxt(file))